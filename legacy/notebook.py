# -*- coding: utf-8 -*-
"""MPfSMl.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hcmTnKLOlGSji4GJS7dIMkub6WJRGZ_1
"""

Modelo = "medium" # @param ["tiny", "base", "small", "medium", "large"]
Idioma = "Portugu√™s"  # @param ["Afric√¢ner", "Alban√™s", "Alem√£o", "Am√°rico", "√Årabe", "Arm√™nio", "√Åsamo", "Azerbaijano", "Basco", "Bielorrusso", "Bengali", "B√≥snio", "B√∫lgaro", "Catal√£o", "Cazaque", "Cebuano", "Chin√™s", "Coreano", "Croata", "Dinamarqu√™s", "Eslovaco", "Esloveno", "Espanhol", "Esperanto", "Estoniano", "Filipino", "Finland√™s", "Franc√™s", "Galego", "Georgiano", "Grego", "Guzerate", "Haitiano", "Hau√ß√°", "Hebraico", "Hindi", "Hmong", "Holand√™s", "H√∫ngaro", "Igbo", "Indon√©sio", "Ingl√™s", "Irland√™s", "Island√™s", "Italiano", "Japon√™s", "Javan√™s", "Canar√™s", "Khmer", "Laosiano", "Latim", "Let√£o", "Lituano", "Luxemburgu√™s", "Maced√¥nio", "Malaiala", "Malaio", "Malgaxe", "Malt√™s", "Maori", "Marata", "Mianmar", "Mongol", "Nepal√™s", "Noruegu√™s", "Pachto", "Panjabi", "Persa", "Polon√™s", "Portugu√™s", "Quemer", "Quirguiz", "Qu√≠chua", "Romeno", "Russo", "Samoano", "S√©rvio", "Sindi", "Sinhala", "Somali", "Soto", "Sueco", "Sua√≠li", "Tajique", "T√¢mil", "T√°rtaro", "Telugo", "Tailand√™s", "Tcheco", "Tibetano", "Tigr√≠nia", "Turco", "Turcomeno", "Ucraniano", "Urdu", "Uzbeque", "Vietnamita", "Xhosa", "Yidis", "Zulu"]
ChaveGemini = "AIzaSyAjJmwlHPVbv5V-w_NyQyJROy7UGNoUhUg" # @param {"type":"string","placeholder":"Cole a chave GEMINI aqui"}

idiomas = {
    "Afric√¢ner": "af", "Alban√™s": "sq", "Alem√£o": "de", "Am√°rico": "am", "√Årabe": "ar", "Arm√™nio": "hy",
    "√Åsamo": "as", "Azerbaijano": "az", "Basco": "eu", "Bielorrusso": "be", "Bengali": "bn", "B√≥snio": "bs",
    "B√∫lgaro": "bg", "Catal√£o": "ca", "Cazaque": "kk", "Cebuano": "ceb", "Chin√™s": "zh", "Coreano": "ko",
    "Croata": "hr", "Dinamarqu√™s": "da", "Eslovaco": "sk", "Esloveno": "sl", "Espanhol": "es",
    "Esperanto": "eo", "Estoniano": "et", "Filipino": "tl", "Finland√™s": "fi", "Franc√™s": "fr",
    "Galego": "gl", "Georgiano": "ka", "Grego": "el", "Guzerate": "gu", "Haitiano": "ht", "Hau√ß√°": "ha",
    "Hebraico": "he", "Hindi": "hi", "Hmong": "hmn", "Holand√™s": "nl", "H√∫ngaro": "hu", "Igbo": "ig",
    "Indon√©sio": "id", "Ingl√™s": "en", "Irland√™s": "ga", "Island√™s": "is", "Italiano": "it",
    "Japon√™s": "ja", "Javan√™s": "jw", "Canar√™s": "kn", "Khmer": "km", "Laosiano": "lo", "Latim": "la",
    "Let√£o": "lv", "Lituano": "lt", "Luxemburgu√™s": "lb", "Maced√¥nio": "mk", "Malaiala": "ml",
    "Malaio": "ms", "Malgaxe": "mg", "Malt√™s": "mt", "Maori": "mi", "Marata": "mr", "Mianmar": "my",
    "Mongol": "mn", "Nepal√™s": "ne", "Noruegu√™s": "no", "Pachto": "ps", "Panjabi": "pa", "Persa": "fa",
    "Polon√™s": "pl", "Portugu√™s": "pt", "Quemer": "km", "Quirguiz": "ky", "Qu√≠chua": "qu",
    "Romeno": "ro", "Russo": "ru", "Samoano": "sm", "S√©rvio": "sr", "Sindi": "sd", "Sinhala": "si",
    "Somali": "so", "Soto": "st", "Sueco": "sv", "Sua√≠li": "sw", "Tajique": "tg", "T√¢mil": "ta",
    "T√°rtaro": "tt", "Telugo": "te", "Tailand√™s": "th", "Tcheco": "cs", "Tibetano": "bo",
    "Tigr√≠nia": "ti", "Turco": "tr", "Turcomeno": "tk", "Ucraniano": "uk", "Urdu": "ur", "Uzbeque": "uz",
    "Vietnamita": "vi", "Xhosa": "xh", "Yidis": "yi", "Zulu": "zu"
}

sigla = idiomas[Idioma]
print(f"Idioma selecionado: {Idioma} ({sigla})")

"""# C√≥digo
N√£o precisa mexer, aqui tem os prompts, caso queira alterar.

## Instala√ß√£o das Biliotecas
"""

!pip install pdfkit

!sudo apt install wkhtmltopdf

!pip install openai-whisper

!pip install markdown

!pip install genanki

!pip install selenium webdriver-manager

!apt update
!apt install -y chromium-chromedriver
!cp /usr/lib/chromium-browser/chromedriver /usr/bin

import whisper
import argparse
import os
from datetime import datetime
import torch
import nltk
from nltk.corpus import stopwords
import string
import requests
import markdown
import shutil
from google.colab import userdata
from google.colab import files
import random
import genanki
import google.generativeai as genai
import json
import pdfkit
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import urllib.parse
import time
import re
if ChaveGemini != "Cole a chave GEMINI aqui":
  API_KEY = ChaveGemini
else:
  API_KEY = userdata.get('GOOGLE_API_KEY')

URL = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={API_KEY}"

chrome_options = Options()
chrome_options.add_argument("--headless")
chrome_options.add_argument("--disable-dev-shm-usage")
chrome_options.add_argument("--no-sandbox")
#chrome_options.binary_location = "/usr/bin/chromium-browser"

driver = webdriver.Chrome(options=chrome_options)

def pegar_imagens_com_selenium(pesquisa):
    query = urllib.parse.quote(pesquisa)
    url = f"https://www.google.com/search?q={query}&udm=2&hl=pt-BR&tbm=isch"

    try:
        # Abrir uma nova aba para cada busca
        driver.execute_script(f"window.open('{url}', '_blank');")
        driver.switch_to.window(driver.window_handles[-1])  # Mudar para a nova aba
        time.sleep(2)

        # Encontra todas as imagens de pr√©-visualiza√ß√£o
        imagens = driver.find_elements(By.TAG_NAME, "img")

        links = []
        # Procura pelos links das imagens
        for i, img in enumerate(imagens):
            src = img.get_attribute("src") or img.get_attribute("data-src")
            if src:
                links.append(src)

        # Encontrar o √≠ndice do logo do Google (caso exista)
        l = 0
        for i, link in enumerate(links):
            if link == 'https://fonts.gstatic.com/s/i/productlogos/googleg/v6/24px.svg':
                l = i  # Encontramos a posi√ß√£o do logo do Google

        # Pega o link da imagem que deve ser clicada
        link_imagem = links[l + 1] if len(links) > l + 1 else links[0]

        # Agora, vamos interagir com a imagem usando o link
        for img in imagens:
            src = img.get_attribute("src") or img.get_attribute("data-src")
            if src == link_imagem:
                img.click()
                time.sleep(2)  # Espera para a imagem abrir

                # Espera at√© que a <div> com jscontroller="luWJre" esteja vis√≠vel
                try:
                    # Localiza a <div> que cont√©m a imagem de alta resolu√ß√£o
                    div_com_imagem = WebDriverWait(driver, 4).until(
                        EC.presence_of_element_located((By.CSS_SELECTOR, 'div[jscontroller="luWJre"]'))
                    )

                    # Dentro dessa <div>, encontra todas as imagens com a URL de alta qualidade
                    imagens_alta_resolucao = div_com_imagem.find_elements(By.TAG_NAME, 'img')

                    # Captura os links das imagens de alta qualidade
                    links_imagens_alta_resolucao = []
                    for imagem in imagens_alta_resolucao:
                        imagem_src = imagem.get_attribute("src")
                        if imagem_src and imagem_src != src:
                            links_imagens_alta_resolucao.append(imagem_src)

                    # Se houver imagens de alta resolu√ß√£o, retorna o primeiro link
                    if links_imagens_alta_resolucao:
                        return links_imagens_alta_resolucao[1]

                except Exception as e:
                    print("Erro ao capturar as imagens de alta qualidade:", e)
                    return []
    finally:
        print('Imagem ok.')

def preparar_markdown_para_busca(texto_markdown):
    def substituir(match):
        descricao = match.group(1).strip()
        link = pegar_imagens_com_selenium(descricao)
        # Substitui pelo markdown de imagem usando a descri√ß√£o como alt text e como texto tempor√°rio de URL
        return f"![{descricao}]({link})"

    novo_markdown = re.sub(r"\(IMAGEM:\s*(.*?)\)", substituir, texto_markdown)
    driver.quit()
    return novo_markdown

notion_style = """
<style>
  body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Segoe UI Emoji", "Apple Color Emoji";
      max-width: 800px;
      margin: 10px auto;
      padding: 10px;
      line-height: 1.6;
      font-size: 16px;
      color: #2e2e2e;
      background: #ffffff;
  }
  h1, h2, h3 {
      border-bottom: 1px solid #eaeaea;
      padding-bottom: 0.3em;
      margin-top: 1.4em;
  }
  code {
      background-color: #f6f8fa;
      padding: 2px 4px;
      border-radius: 3px;
      font-size: 90%;
      font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  }
  pre code {
      background-color: #f6f8fa;
      display: block;
      padding: 1em;
      overflow-x: auto;
  }
  blockquote {
      border-left: 4px solid #dfe2e5;
      padding: 0 1em;
      color: #6a737d;
  }
  table {
      border-collapse: collapse;
      width: 100%;
  }
  th, td {
      border: 1px solid #dfe2e5;
      padding: 6px 13px;
  }
  th {
      background-color: #f6f8fa;
  }
  img {
      height: auto;
      width: auto;
      display: block;
      object-fit: contain;  /* Faz com que a imagem se ajuste sem distorcer */
      max-width: 80%;  /* Limita a largura da imagem a 80% da largura da p√°gina */
      height: auto;    /* Mant√©m a propor√ß√£o da imagem */
      margin: 20px auto; /* Centraliza as imagens e adiciona margem superior/inferior */

  }
  @page {
      margin: 10mm;
  }
</style>

"""

headers = {
    "Content-Type": "application/json"
}

def argumentos_cli():
    parser = argparse.ArgumentParser(description="Transcri√ß√£o e resumo de aulas com Whisper + Gemini")

    parser.add_argument('--audio', type=str, help='Caminho para o arquivo de √°udio a ser processado')
    parser.add_argument('--modelo', type=str, default='base', help='Modelo do Whisper a ser usado (base, small, medium, large, etc.)')

    return parser.parse_args()

def gerar_pdf_markdown(markdown_text, pasta_destino, nome_pdf):
    markdown_text = preparar_markdown_para_busca(markdown_text)
    html_content = markdown.markdown(markdown_text, extensions=["extra", "tables", "fenced_code"])
    full_html = f"<!DOCTYPE html><html><head><meta charset='utf-8'>{notion_style}</head><body>{html_content}</body></html>"
    caminho_pdf = os.path.join(pasta_destino, nome_pdf)
    options = {
        'page-size': 'A4',  # Tamanho A4
        'margin-top': '2cm',  # Margem superior (ABNT)
        'margin-right': '2cm',  # Margem direita (ABNT)
        'margin-bottom': '2cm',  # Margem inferior (ABNT)
        'margin-left': '2cm',  # Margem esquerda (ABNT)
        'encoding': 'UTF-8',  # Codifica√ß√£o do texto
        'no-outline': None  # Evita que o PDF tenha um contorno (√∫til para documentos mais limpos)
    }
    pdfkit.from_string(full_html, caminho_pdf, options=options)
    # Gerando o PDF a partir do HTML com as configura√ß√µes definidas
    print(f"‚úÖ PDF gerado com sucesso: {caminho_pdf}")

def criar_baralho(flashcards, nome_baralho):
    # IDs √∫nicos (voc√™ pode gerar novos com random.randint se quiser)
    modelo_id = 1607392319
    baralho_id = random.randint(1 << 28, (1 << 30) - 1)

    # Modelo do Anki
    modelo = genanki.Model(
        model_id=modelo_id,
        name='MPfSMl',
        fields=[
            {'name': 'Pergunta'},
            {'name': 'Resposta'},
        ],
        templates=[
            {
                'name': 'Cart√£o MPfSMl',
                'qfmt': '{{Pergunta}}',
                'afmt': '{{FrontSide}}<hr id="answer">{{Resposta}}',
            },
        ]
    )

    nameBaralho = 'MPfSMl::'+nome_baralho

    # Baralho
    baralho = genanki.Deck(
        deck_id=baralho_id,
        name=nameBaralho
    )

    # Adiciona flashcards
    for card in flashcards:
        nota = genanki.Note(
            model=modelo,
            fields=[card['Pergunta'], card['Resposta']]
        )
        baralho.add_note(nota)

    # Salva na raiz
    nome_arquivo = f'{nome_baralho}.apkg'
    genanki.Package(baralho).write_to_file(nome_arquivo)
    print(f'Baralho "{nome_arquivo}" criado com sucesso na raiz!')

"""## Prompts enviados ao gemini"""

def gerarFlashcards(resumo):
  # Modelo que voc√™ quer usar
  genai.configure(api_key=API_KEY)
  model = genai.GenerativeModel('gemini-2.0-flash')

  # Prompt para gerar flashcards
  prompt = f"""

  A partir do conte√∫do abaixo (resumo da transcri√ß√£o), crie flashcards no formato JSON, com foco em aprendizado acad√™mico e m√©dico.

  A resposta ser√° convertida em .apkg, ent√£o:

  - Use formata√ß√£o JSON limpa, apenas o json sem nenhuma outra explica√ß√£o
  - Cada flashcard deve ser composto por uma pergunta e sua resposta
  - Inclua as informa√ß√µes m√©dicas essenciais, de forma objetiva e concisa

  Contexto essencial:

  Este conte√∫do ser√° usado para revis√µes r√°pidas e eficazes, com foco em memoriza√ß√£o ativa para estudantes de medicina. Para isso, os flashcards devem:

  - Apresentar perguntas cl√≠nicas relevantes baseadas no conte√∫do
  - Utilizar a estrutura "pergunta e resposta" de forma clara e objetiva
  - Evitar usar quest√µes muito gen√©ricas ou vagas

  A resposta deve conter APENAS uma lista JSON, sem nenhuma explica√ß√£o fora do JSON.

  Cada item deve ter esta estrutura:

  [
    {{
      "Pergunta": "Qual √© o principal mediador da resposta inflamat√≥ria aguda?",
      "Resposta": "A histamina √© um dos principais mediadores da resposta inflamat√≥ria aguda."
    }},
    ...
  ]

  Resumo para base dos flashcards:

  \"\"\"{resumo}\"\"\"
  """

  # Gera√ß√£o do conte√∫do
  response = model.generate_content(prompt)

  # Remove a primeira e a √∫ltima linha da resposta
  preJson = '\n'.join(response.text.splitlines()[1:-1])

  # Converte string para JSON
  flashcards = json.loads(preJson)

  return(flashcards)

def normatizarFala(transcricao: str) -> tuple[str, str]:
    prompt_estudo = f"""
Voc√™ receber√° um texto transcrito automaticamente a partir de uma aula oral em medicina. O texto estar√° repleto de v√≠cios de linguagem, repeti√ß√µes, erros gramaticais e trechos desconexos, pois foi transcrito de fala espont√¢nea.
Sua tarefa √© limpar o texto, tornando-o fluido e compreens√≠vel para leitura, SEM RESUMIR e SEM OMITIR conte√∫do. Siga estas instru√ß√µes:
Remova v√≠cios de linguagem (por exemplo: "n√©", "t√° bom", "entendeu", "certo", "assim", "vamos l√°", "beleza", "tipo", "enfim", "ent√£o", "ok", "ai", "calma", "a√≠", "senhor", "gente", "vamos ver", "musica", "cantando", "t√° vendo" e semelhantes).
Elimine repeti√ß√µes redundantes e ru√≠dos de fala.
Corrija erros gramaticais, de concord√¢ncia e de pontua√ß√£o.
Mantenha a sequ√™ncia l√≥gica das ideias conforme expostas pelo professor, mesmo que informalmente.
N√£o mude o conte√∫do, n√£o resuma, n√£o interprete, n√£o adicione nem omita informa√ß√µes.
Deixe o texto fluido e leg√≠vel, com frases completas e bem estruturadas, adequado para um material de estudo ou roteiro de revis√£o.
Preserve a terminologia t√©cnica utilizada (termos m√©dicos, anat√¥micos, fisiol√≥gicos, etc.).
Ao final, entregue o texto reescrito como texto limpo e fluido, sem qualquer coment√°rio, explica√ß√£o ou marca√ß√£o adicional. Apenas o texto final reescrito.

Texto para base da corre√ß√£o:
{transcricao}
"""

    data = {"contents": [{"parts": [{"text": prompt_estudo}]}]}

    response = requests.post(URL, headers=headers, json=data)

    if response.status_code == 200:
        result = response.json()
        markdown_raw = result['candidates'][0]['content']['parts'][0]['text']

        markdown_clean = markdown_raw.strip().split("\n", 1)[-1].strip()  # Clean and trim the result

        titulo = next((line.strip("# ").strip() for line in markdown_clean.split("\n") if line.startswith("# ")), "Guia")
        return f"{titulo}.pdf", markdown_clean
    else:
        raise Exception(f"Erro na requisi√ß√£o: {response.status_code}\n{response.text}")

def gerar_resumo_markdown(transcricao: str) -> tuple[str, str]:
    prompt = f"""
Sem fornecer coment√°rios, explica√ß√µes ou qualquer texto adicional fora do solicitado, gere um resumo t√©cnico, did√°tico e completo da transcri√ß√£o da aula abaixo.

O conte√∫do deve ser integralmente fiel √† transcri√ß√£o, sem omiss√µes de informa√ß√µes relevantes ‚Äî mesmo que aparentem ser redundantes.
Sempre que necess√°rio para garantir clareza, preencha lacunas conceituais com explica√ß√µes embasadas e complementos t√©cnicos adequados ao n√≠vel de um aluno de medicina.

Inclua, quando pertinente, contextos cl√≠nicos, fisiol√≥gicos, anat√¥micos ou embriol√≥gicos que favore√ßam a assimila√ß√£o do tema.

O resumo deve ser entregue exclusivamente em Markdown puro, formatado no estilo visual do Notion:

Use t√≠tulos com se√ß√µes hier√°rquicas organizadas (com #, ##, ###).

Utilize listas, subt√≥picos, tabelas e destaques visuais sempre que for √∫til √† did√°tica.

Para conceitos que exigem suporte visual para pleno entendimento:

insira no local apropriado a marca (IMAGEM: descri√ß√£o precisa do que deve ser pesquisado no Google Images), sem fornecer links ou imagens, apenas a descri√ß√£o exata e sucinta do que deve ser procurado. Fa√ßa a adi√ß√£o de imagens apenas em locais extremamente importantes e imprescind√≠veis ao aprendizado, para evitar poluir o PDF.

Seja objetivo, t√©cnico e pedagogicamente organizado.

Retorne apenas o conte√∫do em Markdown, sem qualquer outro tipo de resposta.

Transcri√ß√£o da aula:
{transcricao}
"""
    data = {
        "contents": [
            {
                "parts": [
                    {"text": prompt}
                ]
            }
        ]
    }

    response = requests.post(URL, headers=headers, json=data)

    if response.status_code == 200:
        result = response.json()
        markdown_raw = result['candidates'][0]['content']['parts'][0]['text']

        if markdown_raw.startswith("```markdown") and markdown_raw.endswith("```"):
            markdown_clean = "\n".join(markdown_raw.strip().split("\n")[1:-1])
        else:
            markdown_clean = markdown_raw

        titulo = ""
        for line in markdown_clean.split("\n"):
            if line.strip().startswith("# "):
                titulo = line.strip("# ").strip()
                break

        titulo = titulo + '.pdf'
        return titulo, markdown_clean
    else:
        raise Exception(f"Erro na requisi√ß√£o: {response.status_code}\n{response.text}")

def gerar_questoes_markdown(texto_base):
    prompt = f"""
    A partir do conte√∫do abaixo, crie 10 quest√µes de cada n√≠vel de dificuldade (f√°cil, m√©dio, dif√≠cil), com foco em refor√ßo de compreens√£o m√©dica e acad√™mica. Siga as regras:

    - Crie 10 quest√µes f√°ceis, 10 m√©dias e 10 dif√≠ceis.
    - N√£o agrupe as quest√µes em f√°ceis, m√©dias ou dificeis, o aluno s√≥ deve saber ao ver o gabarito.
    - Fa√ßa da quest√£o 01 at√© a 30, sem agrupar por dificuldade.
    - As respostas das quest√µes devem estar APENAS excluivamente na √°rea de gabaritos.
    - As quest√µes devem ser formuladas em formatos variados:
      - Quest√µes objetivas (com alternativas)
      - Quest√µes de resposta curta
      - Quest√µes de verdadeiro ou falso
      - Casos cl√≠nicos

    - As alternativas, ou as respostas curtas, devem ser realistas e educativas, com a resposta correta claramente identificada.
    - As alternativas devem ser equilibradas em dificuldade, sem nenhuma √≥bvia ou excessivamente f√°cil.
    - Cada quest√£o deve ser seguida de justificativa detalhada explicando o racioc√≠nio por tr√°s da resposta correta.
    - N√£o forne√ßa explica√ß√µes adicionais al√©m das instru√ß√µes acima.

    A sa√≠da deve estar no formato Markdown, com as quest√µes bem organizadas e agrad√°veis para visualiza√ß√£o e impress√£o. Evite usar links e mantenha a formata√ß√£o simples, para que as quest√µes sejam facilmente leg√≠veis e prontas para serem impressas. As alternativas devem ser listadas de forma clara, e cada justificativa deve vir logo ap√≥s a quest√£o correspondente.

    Para as quest√µes de resposta curta, inclua um espa√ßo de linhas (sublinhado) do tamanho necess√°rio para a resposta, usando a seguinte formata√ß√£o:
    ________________________

    Sa√≠da: Responda no formato Markdown com as seguintes informa√ß√µes:

    ### Quest√µes:

    1.  **Pergunta:** (enunciado da quest√£o)
       - Alternativas:
         - A) Alternativa 1
         - B) Alternativa 2
         - C) Alternativa 3
         - D) Alternativa 4
         - E) Alternativa 5

    2.  **Pergunta:** (enunciado da quest√£o)
       - Alternativas:
         - A) Verdadeiro
         - B) Falso (justificar aqui:______________________________)

    3. **Pergunta:** (enunciado da quest√£o)
       **Resposta:**
       _____________________________________________________________

    Repita as 30 quest√µes, seguindo o mesmo formato

    ### Gabarito:
    1. **Resposta:** A
       **Justificativa:** Explica√ß√£o detalhada do porqu√™ a alternativa A √© a correta.
       **N√≠vel: f√°cil/m√©dio/dif√≠cil**

    2. **Resposta:** B
       **Justificativa:** Explica√ß√£o detalhada do porqu√™ a alternativa B √© a correta.
       **N√≠vel: f√°cil/m√©dio/dif√≠cil**

    3. **Resposta:** Falso
       **Justificativa:** Explica√ß√£o detalhada do que tornou a quest√£o falsa ou verdadeira.
       **N√≠vel: f√°cil/m√©dio/dif√≠cil**

    (Repita para todas as quest√µes)

    ### Texto base:
    {texto_base}
    """
    data = {"contents": [{"parts": [{"text": prompt}]}]}

    response = requests.post(URL, headers=headers, json=data)

    if response.status_code == 200:
        result = response.json()
        markdown_raw = result['candidates'][0]['content']['parts'][0]['text']

        markdown_clean = markdown_raw.strip().split("\n", 1)[-1].strip()  # Clean and trim the result

        titulo = 'questoes'
        return f"{titulo}.pdf", markdown_clean
    else:
        raise Exception(f"Erro na requisi√ß√£o: {response.status_code}\n{response.text}")

"""## Execu√ß√£o da Transcri√ß√£o e Passagem ao PDF."""

def escolher_dispositivo():
    if torch.cuda.is_available():
        return "cuda"
    else:
        return "cpu"

def formatar_timestamp(segundos):
    h, m = divmod(int(segundos), 3600)
    m, s = divmod(m, 60)
    return f"{h:02}:{m:02}:{s:02}"

def remover_stopwords(texto):
    try:
        stopwords.words('portuguese')
    except LookupError:
        nltk.download('stopwords')

    stop_words = set(stopwords.words("portuguese"))
    texto_sem_pontuacao = texto.translate(str.maketrans('', '', string.punctuation))
    palavras = texto_sem_pontuacao.split()

    palavras_filtradas = [
        palavra for palavra in palavras
        if palavra.lower() not in stop_words
    ]
    return " ".join(palavras_filtradas)

def transcrever_audio(caminho_audio, modelo="base", exportar=True, dispositivo="cpu"):
    if not os.path.exists(caminho_audio):
        raise FileNotFoundError(f"Arquivo n√£o encontrado: {caminho_audio}")

    print(f"üîç Carregando modelo Whisper '{modelo}' no dispositivo {dispositivo.upper()}...")
    model = whisper.load_model(modelo).to(dispositivo)

    print("üì° Transcrevendo √°udio...")
    resultado = model.transcribe(caminho_audio, verbose=False, language=sigla)

    com_tempos = []
    sem_tempos = []

    for s in resultado['segments']:
        texto = s['text'].strip()
        com_tempos.append(f"[{formatar_timestamp(s['start'])} - {formatar_timestamp(s['end'])}] {texto}")
        sem_tempos.append(texto)

    texto_com_tempos = "\n\n".join(com_tempos)
    texto_sem_tempos = " ".join(sem_tempos)
    texto_sem_tempos = remover_stopwords(texto_sem_tempos)

    print("\n‚úÖ Transcri√ß√£o finalizada!\n")
    if exportar:
        salvar_transcricoes(texto_com_tempos, texto_sem_tempos, caminho_audio)

    return texto_com_tempos, texto_sem_tempos

def salvar_transcricoes(com_tempos, sem_tempos, caminho_audio):
    base = os.path.splitext(os.path.basename(caminho_audio))[0]
    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")

    arquivos = {
        f"com_tempos_{base}.txt": com_tempos,
        f"sem_tempos_{base}.txt": sem_tempos
    }

    for nome, conteudo in arquivos.items():
        with open(nome, "w", encoding="utf-8") as f:
            f.write(conteudo)
        print(f"üìÅ Arquivo salvo: {nome}")

def mover_arquivos_processados(pasta_destino, base_nome):
    extensoes = (".txt", '.apkg')
    for arquivo in os.listdir("."):
        if base_nome in arquivo and arquivo.endswith(extensoes):
            origem = os.path.join(".", arquivo)
            destino = os.path.join(pasta_destino, arquivo)
            shutil.move(origem, destino)
            print(f"üì¶ Arquivo movido: {arquivo}")

def escolher_arquivo_audio(diretorio):
    arquivos_audio = [f for f in os.listdir(diretorio) if f.lower().endswith(('.mp3', '.wav', '.m4a'))]

    if len(arquivos_audio) == 0:
        print("‚ùå Nenhum arquivo de √°udio encontrado na raiz.")
        return None

    if len(arquivos_audio) == 1:
        return arquivos_audio[0]

    print("üîä M√∫ltiplos arquivos de √°udio encontrados. Escolha um para processar via flag --audio.")
    print('Ver documenta√ß√£o.')
    return (2/0)/0


#MAIN .PY
def transcrever_Resumir(diretorio):
    arquivo_audio = escolher_arquivo_audio(diretorio)

    if arquivo_audio:
        caminho_audio = os.path.join(diretorio, arquivo_audio)
        modelo = Modelo
        dispositivo = escolher_dispositivo()

        nome_arquivo_sem_ext = os.path.splitext(arquivo_audio)[0]
        pasta_destino = os.path.join("aulas_processadas", nome_arquivo_sem_ext)

        if os.path.exists(pasta_destino):
            print(f"‚ö†Ô∏è Sobrescrevendo")
        else:
            os.makedirs(pasta_destino)

        try:
            # Verificar se os arquivos com_tempos_ e sem_tempos_ j√° existem
            arquivo_com_tempos = os.path.join('.', f"com_tempos_{nome_arquivo_sem_ext}.txt")
            arquivo_sem_tempos = os.path.join('.', f"sem_tempos_{nome_arquivo_sem_ext}.txt")

            if os.path.exists(arquivo_com_tempos) and os.path.exists(arquivo_sem_tempos):
                print("üîÑ Arquivos encontrados, carregando...")
                with open(arquivo_com_tempos, 'r') as f:
                    withTime = f.read()
                with open(arquivo_sem_tempos, 'r') as f:
                    noTime = f.read()
            else:
                print("üîÑ Realizando transcri√ß√£o...")
                withTime, noTime = transcrever_audio(caminho_audio, modelo=modelo, exportar=True, dispositivo=dispositivo)
                nonNormat = noTime #PARA O RESUMO, O N√ÉO NORMATIZADO TEM RESULTADOS LIGEIRAMENTE MELHORES, PORTANTO, RESUMO FEITO COM NONNORMAT.
                print("\nüìù Normatizando fala.")
                varbs, noTime = normatizarFala(noTime)
                print("\n‚úÖ Texto completo!")

                # Salvar os arquivos gerados
                with open(arquivo_com_tempos, 'w') as f:
                    f.write(withTime)
                with open(arquivo_sem_tempos, 'w') as f:
                    f.write(noTime)


            print("\nüìù Criando resumo")
            tituloMD, resumoMD = gerar_resumo_markdown(nonNormat)
            print("\n‚úÖ Resumo pronto!")

            print("\nüìù Criando quest√µes")
            tituloQuestoes, QuestoesMD = gerar_questoes_markdown(resumoMD)
            print("\n‚úÖ Quest√µes prontas!")

            print('\nüìùCriando Flashcards')
            jsonFlashCards = gerarFlashcards(resumoMD)
            criar_baralho(flashcards=jsonFlashCards, nome_baralho=nome_arquivo_sem_ext)
            print("\n‚úÖ Flashcards prontas!")

            gerar_pdf_markdown(resumoMD, pasta_destino, "resumo.pdf")
            gerar_pdf_markdown(QuestoesMD, pasta_destino, "questoes.pdf")

            # Mover os arquivos usados para a pasta destino
            mover_arquivos_processados(f"aulas_processadas/{nome_arquivo_sem_ext}", nome_arquivo_sem_ext)
            # Criar um arquivo ZIP com os arquivos processados
            zip_filename = f"{nome_arquivo_sem_ext}_aulas"
            shutil.make_archive(zip_filename, 'zip', pasta_destino)

            # Fazer o download do arquivo ZIP
            files.download(f"{zip_filename}.zip")

        except Exception as erro:
            print(f"‚ùå Erro: {erro}")

"""# Execu√ß√£o"""

transcrever_Resumir('.')
driver.quit()