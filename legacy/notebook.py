# -*- coding: utf-8 -*-
"""MPfSMl.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hcmTnKLOlGSji4GJS7dIMkub6WJRGZ_1
"""

Modelo = "medium" # @param ["tiny", "base", "small", "medium", "large"]
Idioma = "Português"  # @param ["Africâner", "Albanês", "Alemão", "Amárico", "Árabe", "Armênio", "Ásamo", "Azerbaijano", "Basco", "Bielorrusso", "Bengali", "Bósnio", "Búlgaro", "Catalão", "Cazaque", "Cebuano", "Chinês", "Coreano", "Croata", "Dinamarquês", "Eslovaco", "Esloveno", "Espanhol", "Esperanto", "Estoniano", "Filipino", "Finlandês", "Francês", "Galego", "Georgiano", "Grego", "Guzerate", "Haitiano", "Hauçá", "Hebraico", "Hindi", "Hmong", "Holandês", "Húngaro", "Igbo", "Indonésio", "Inglês", "Irlandês", "Islandês", "Italiano", "Japonês", "Javanês", "Canarês", "Khmer", "Laosiano", "Latim", "Letão", "Lituano", "Luxemburguês", "Macedônio", "Malaiala", "Malaio", "Malgaxe", "Maltês", "Maori", "Marata", "Mianmar", "Mongol", "Nepalês", "Norueguês", "Pachto", "Panjabi", "Persa", "Polonês", "Português", "Quemer", "Quirguiz", "Quíchua", "Romeno", "Russo", "Samoano", "Sérvio", "Sindi", "Sinhala", "Somali", "Soto", "Sueco", "Suaíli", "Tajique", "Tâmil", "Tártaro", "Telugo", "Tailandês", "Tcheco", "Tibetano", "Tigrínia", "Turco", "Turcomeno", "Ucraniano", "Urdu", "Uzbeque", "Vietnamita", "Xhosa", "Yidis", "Zulu"]
ChaveGemini = "AIzaSyAjJmwlHPVbv5V-w_NyQyJROy7UGNoUhUg" # @param {"type":"string","placeholder":"Cole a chave GEMINI aqui"}

idiomas = {
    "Africâner": "af", "Albanês": "sq", "Alemão": "de", "Amárico": "am", "Árabe": "ar", "Armênio": "hy",
    "Ásamo": "as", "Azerbaijano": "az", "Basco": "eu", "Bielorrusso": "be", "Bengali": "bn", "Bósnio": "bs",
    "Búlgaro": "bg", "Catalão": "ca", "Cazaque": "kk", "Cebuano": "ceb", "Chinês": "zh", "Coreano": "ko",
    "Croata": "hr", "Dinamarquês": "da", "Eslovaco": "sk", "Esloveno": "sl", "Espanhol": "es",
    "Esperanto": "eo", "Estoniano": "et", "Filipino": "tl", "Finlandês": "fi", "Francês": "fr",
    "Galego": "gl", "Georgiano": "ka", "Grego": "el", "Guzerate": "gu", "Haitiano": "ht", "Hauçá": "ha",
    "Hebraico": "he", "Hindi": "hi", "Hmong": "hmn", "Holandês": "nl", "Húngaro": "hu", "Igbo": "ig",
    "Indonésio": "id", "Inglês": "en", "Irlandês": "ga", "Islandês": "is", "Italiano": "it",
    "Japonês": "ja", "Javanês": "jw", "Canarês": "kn", "Khmer": "km", "Laosiano": "lo", "Latim": "la",
    "Letão": "lv", "Lituano": "lt", "Luxemburguês": "lb", "Macedônio": "mk", "Malaiala": "ml",
    "Malaio": "ms", "Malgaxe": "mg", "Maltês": "mt", "Maori": "mi", "Marata": "mr", "Mianmar": "my",
    "Mongol": "mn", "Nepalês": "ne", "Norueguês": "no", "Pachto": "ps", "Panjabi": "pa", "Persa": "fa",
    "Polonês": "pl", "Português": "pt", "Quemer": "km", "Quirguiz": "ky", "Quíchua": "qu",
    "Romeno": "ro", "Russo": "ru", "Samoano": "sm", "Sérvio": "sr", "Sindi": "sd", "Sinhala": "si",
    "Somali": "so", "Soto": "st", "Sueco": "sv", "Suaíli": "sw", "Tajique": "tg", "Tâmil": "ta",
    "Tártaro": "tt", "Telugo": "te", "Tailandês": "th", "Tcheco": "cs", "Tibetano": "bo",
    "Tigrínia": "ti", "Turco": "tr", "Turcomeno": "tk", "Ucraniano": "uk", "Urdu": "ur", "Uzbeque": "uz",
    "Vietnamita": "vi", "Xhosa": "xh", "Yidis": "yi", "Zulu": "zu"
}

sigla = idiomas[Idioma]
print(f"Idioma selecionado: {Idioma} ({sigla})")

"""# Código
Não precisa mexer, aqui tem os prompts, caso queira alterar.

## Instalação das Biliotecas
"""

!pip install pdfkit

!sudo apt install wkhtmltopdf

!pip install openai-whisper

!pip install markdown

!pip install genanki

!pip install selenium webdriver-manager

!apt update
!apt install -y chromium-chromedriver
!cp /usr/lib/chromium-browser/chromedriver /usr/bin

import whisper
import argparse
import os
from datetime import datetime
import torch
import nltk
from nltk.corpus import stopwords
import string
import requests
import markdown
import shutil
from google.colab import userdata
from google.colab import files
import random
import genanki
import google.generativeai as genai
import json
import pdfkit
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import urllib.parse
import time
import re
if ChaveGemini != "Cole a chave GEMINI aqui":
  API_KEY = ChaveGemini
else:
  API_KEY = userdata.get('GOOGLE_API_KEY')

URL = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={API_KEY}"

chrome_options = Options()
chrome_options.add_argument("--headless")
chrome_options.add_argument("--disable-dev-shm-usage")
chrome_options.add_argument("--no-sandbox")
#chrome_options.binary_location = "/usr/bin/chromium-browser"

driver = webdriver.Chrome(options=chrome_options)

def pegar_imagens_com_selenium(pesquisa):
    query = urllib.parse.quote(pesquisa)
    url = f"https://www.google.com/search?q={query}&udm=2&hl=pt-BR&tbm=isch"

    try:
        # Abrir uma nova aba para cada busca
        driver.execute_script(f"window.open('{url}', '_blank');")
        driver.switch_to.window(driver.window_handles[-1])  # Mudar para a nova aba
        time.sleep(2)

        # Encontra todas as imagens de pré-visualização
        imagens = driver.find_elements(By.TAG_NAME, "img")

        links = []
        # Procura pelos links das imagens
        for i, img in enumerate(imagens):
            src = img.get_attribute("src") or img.get_attribute("data-src")
            if src:
                links.append(src)

        # Encontrar o índice do logo do Google (caso exista)
        l = 0
        for i, link in enumerate(links):
            if link == 'https://fonts.gstatic.com/s/i/productlogos/googleg/v6/24px.svg':
                l = i  # Encontramos a posição do logo do Google

        # Pega o link da imagem que deve ser clicada
        link_imagem = links[l + 1] if len(links) > l + 1 else links[0]

        # Agora, vamos interagir com a imagem usando o link
        for img in imagens:
            src = img.get_attribute("src") or img.get_attribute("data-src")
            if src == link_imagem:
                img.click()
                time.sleep(2)  # Espera para a imagem abrir

                # Espera até que a <div> com jscontroller="luWJre" esteja visível
                try:
                    # Localiza a <div> que contém a imagem de alta resolução
                    div_com_imagem = WebDriverWait(driver, 4).until(
                        EC.presence_of_element_located((By.CSS_SELECTOR, 'div[jscontroller="luWJre"]'))
                    )

                    # Dentro dessa <div>, encontra todas as imagens com a URL de alta qualidade
                    imagens_alta_resolucao = div_com_imagem.find_elements(By.TAG_NAME, 'img')

                    # Captura os links das imagens de alta qualidade
                    links_imagens_alta_resolucao = []
                    for imagem in imagens_alta_resolucao:
                        imagem_src = imagem.get_attribute("src")
                        if imagem_src and imagem_src != src:
                            links_imagens_alta_resolucao.append(imagem_src)

                    # Se houver imagens de alta resolução, retorna o primeiro link
                    if links_imagens_alta_resolucao:
                        return links_imagens_alta_resolucao[1]

                except Exception as e:
                    print("Erro ao capturar as imagens de alta qualidade:", e)
                    return []
    finally:
        print('Imagem ok.')

def preparar_markdown_para_busca(texto_markdown):
    def substituir(match):
        descricao = match.group(1).strip()
        link = pegar_imagens_com_selenium(descricao)
        # Substitui pelo markdown de imagem usando a descrição como alt text e como texto temporário de URL
        return f"![{descricao}]({link})"

    novo_markdown = re.sub(r"\(IMAGEM:\s*(.*?)\)", substituir, texto_markdown)
    driver.quit()
    return novo_markdown

notion_style = """
<style>
  body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Segoe UI Emoji", "Apple Color Emoji";
      max-width: 800px;
      margin: 10px auto;
      padding: 10px;
      line-height: 1.6;
      font-size: 16px;
      color: #2e2e2e;
      background: #ffffff;
  }
  h1, h2, h3 {
      border-bottom: 1px solid #eaeaea;
      padding-bottom: 0.3em;
      margin-top: 1.4em;
  }
  code {
      background-color: #f6f8fa;
      padding: 2px 4px;
      border-radius: 3px;
      font-size: 90%;
      font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  }
  pre code {
      background-color: #f6f8fa;
      display: block;
      padding: 1em;
      overflow-x: auto;
  }
  blockquote {
      border-left: 4px solid #dfe2e5;
      padding: 0 1em;
      color: #6a737d;
  }
  table {
      border-collapse: collapse;
      width: 100%;
  }
  th, td {
      border: 1px solid #dfe2e5;
      padding: 6px 13px;
  }
  th {
      background-color: #f6f8fa;
  }
  img {
      height: auto;
      width: auto;
      display: block;
      object-fit: contain;  /* Faz com que a imagem se ajuste sem distorcer */
      max-width: 80%;  /* Limita a largura da imagem a 80% da largura da página */
      height: auto;    /* Mantém a proporção da imagem */
      margin: 20px auto; /* Centraliza as imagens e adiciona margem superior/inferior */

  }
  @page {
      margin: 10mm;
  }
</style>

"""

headers = {
    "Content-Type": "application/json"
}

def argumentos_cli():
    parser = argparse.ArgumentParser(description="Transcrição e resumo de aulas com Whisper + Gemini")

    parser.add_argument('--audio', type=str, help='Caminho para o arquivo de áudio a ser processado')
    parser.add_argument('--modelo', type=str, default='base', help='Modelo do Whisper a ser usado (base, small, medium, large, etc.)')

    return parser.parse_args()

def gerar_pdf_markdown(markdown_text, pasta_destino, nome_pdf):
    markdown_text = preparar_markdown_para_busca(markdown_text)
    html_content = markdown.markdown(markdown_text, extensions=["extra", "tables", "fenced_code"])
    full_html = f"<!DOCTYPE html><html><head><meta charset='utf-8'>{notion_style}</head><body>{html_content}</body></html>"
    caminho_pdf = os.path.join(pasta_destino, nome_pdf)
    options = {
        'page-size': 'A4',  # Tamanho A4
        'margin-top': '2cm',  # Margem superior (ABNT)
        'margin-right': '2cm',  # Margem direita (ABNT)
        'margin-bottom': '2cm',  # Margem inferior (ABNT)
        'margin-left': '2cm',  # Margem esquerda (ABNT)
        'encoding': 'UTF-8',  # Codificação do texto
        'no-outline': None  # Evita que o PDF tenha um contorno (útil para documentos mais limpos)
    }
    pdfkit.from_string(full_html, caminho_pdf, options=options)
    # Gerando o PDF a partir do HTML com as configurações definidas
    print(f"✅ PDF gerado com sucesso: {caminho_pdf}")

def criar_baralho(flashcards, nome_baralho):
    # IDs únicos (você pode gerar novos com random.randint se quiser)
    modelo_id = 1607392319
    baralho_id = random.randint(1 << 28, (1 << 30) - 1)

    # Modelo do Anki
    modelo = genanki.Model(
        model_id=modelo_id,
        name='MPfSMl',
        fields=[
            {'name': 'Pergunta'},
            {'name': 'Resposta'},
        ],
        templates=[
            {
                'name': 'Cartão MPfSMl',
                'qfmt': '{{Pergunta}}',
                'afmt': '{{FrontSide}}<hr id="answer">{{Resposta}}',
            },
        ]
    )

    nameBaralho = 'MPfSMl::'+nome_baralho

    # Baralho
    baralho = genanki.Deck(
        deck_id=baralho_id,
        name=nameBaralho
    )

    # Adiciona flashcards
    for card in flashcards:
        nota = genanki.Note(
            model=modelo,
            fields=[card['Pergunta'], card['Resposta']]
        )
        baralho.add_note(nota)

    # Salva na raiz
    nome_arquivo = f'{nome_baralho}.apkg'
    genanki.Package(baralho).write_to_file(nome_arquivo)
    print(f'Baralho "{nome_arquivo}" criado com sucesso na raiz!')

"""## Prompts enviados ao gemini"""

def gerarFlashcards(resumo):
  # Modelo que você quer usar
  genai.configure(api_key=API_KEY)
  model = genai.GenerativeModel('gemini-2.0-flash')

  # Prompt para gerar flashcards
  prompt = f"""

  A partir do conteúdo abaixo (resumo da transcrição), crie flashcards no formato JSON, com foco em aprendizado acadêmico e médico.

  A resposta será convertida em .apkg, então:

  - Use formatação JSON limpa, apenas o json sem nenhuma outra explicação
  - Cada flashcard deve ser composto por uma pergunta e sua resposta
  - Inclua as informações médicas essenciais, de forma objetiva e concisa

  Contexto essencial:

  Este conteúdo será usado para revisões rápidas e eficazes, com foco em memorização ativa para estudantes de medicina. Para isso, os flashcards devem:

  - Apresentar perguntas clínicas relevantes baseadas no conteúdo
  - Utilizar a estrutura "pergunta e resposta" de forma clara e objetiva
  - Evitar usar questões muito genéricas ou vagas

  A resposta deve conter APENAS uma lista JSON, sem nenhuma explicação fora do JSON.

  Cada item deve ter esta estrutura:

  [
    {{
      "Pergunta": "Qual é o principal mediador da resposta inflamatória aguda?",
      "Resposta": "A histamina é um dos principais mediadores da resposta inflamatória aguda."
    }},
    ...
  ]

  Resumo para base dos flashcards:

  \"\"\"{resumo}\"\"\"
  """

  # Geração do conteúdo
  response = model.generate_content(prompt)

  # Remove a primeira e a última linha da resposta
  preJson = '\n'.join(response.text.splitlines()[1:-1])

  # Converte string para JSON
  flashcards = json.loads(preJson)

  return(flashcards)

def normatizarFala(transcricao: str) -> tuple[str, str]:
    prompt_estudo = f"""
Você receberá um texto transcrito automaticamente a partir de uma aula oral em medicina. O texto estará repleto de vícios de linguagem, repetições, erros gramaticais e trechos desconexos, pois foi transcrito de fala espontânea.
Sua tarefa é limpar o texto, tornando-o fluido e compreensível para leitura, SEM RESUMIR e SEM OMITIR conteúdo. Siga estas instruções:
Remova vícios de linguagem (por exemplo: "né", "tá bom", "entendeu", "certo", "assim", "vamos lá", "beleza", "tipo", "enfim", "então", "ok", "ai", "calma", "aí", "senhor", "gente", "vamos ver", "musica", "cantando", "tá vendo" e semelhantes).
Elimine repetições redundantes e ruídos de fala.
Corrija erros gramaticais, de concordância e de pontuação.
Mantenha a sequência lógica das ideias conforme expostas pelo professor, mesmo que informalmente.
Não mude o conteúdo, não resuma, não interprete, não adicione nem omita informações.
Deixe o texto fluido e legível, com frases completas e bem estruturadas, adequado para um material de estudo ou roteiro de revisão.
Preserve a terminologia técnica utilizada (termos médicos, anatômicos, fisiológicos, etc.).
Ao final, entregue o texto reescrito como texto limpo e fluido, sem qualquer comentário, explicação ou marcação adicional. Apenas o texto final reescrito.

Texto para base da correção:
{transcricao}
"""

    data = {"contents": [{"parts": [{"text": prompt_estudo}]}]}

    response = requests.post(URL, headers=headers, json=data)

    if response.status_code == 200:
        result = response.json()
        markdown_raw = result['candidates'][0]['content']['parts'][0]['text']

        markdown_clean = markdown_raw.strip().split("\n", 1)[-1].strip()  # Clean and trim the result

        titulo = next((line.strip("# ").strip() for line in markdown_clean.split("\n") if line.startswith("# ")), "Guia")
        return f"{titulo}.pdf", markdown_clean
    else:
        raise Exception(f"Erro na requisição: {response.status_code}\n{response.text}")

def gerar_resumo_markdown(transcricao: str) -> tuple[str, str]:
    prompt = f"""
Sem fornecer comentários, explicações ou qualquer texto adicional fora do solicitado, gere um resumo técnico, didático e completo da transcrição da aula abaixo.

O conteúdo deve ser integralmente fiel à transcrição, sem omissões de informações relevantes — mesmo que aparentem ser redundantes.
Sempre que necessário para garantir clareza, preencha lacunas conceituais com explicações embasadas e complementos técnicos adequados ao nível de um aluno de medicina.

Inclua, quando pertinente, contextos clínicos, fisiológicos, anatômicos ou embriológicos que favoreçam a assimilação do tema.

O resumo deve ser entregue exclusivamente em Markdown puro, formatado no estilo visual do Notion:

Use títulos com seções hierárquicas organizadas (com #, ##, ###).

Utilize listas, subtópicos, tabelas e destaques visuais sempre que for útil à didática.

Para conceitos que exigem suporte visual para pleno entendimento:

insira no local apropriado a marca (IMAGEM: descrição precisa do que deve ser pesquisado no Google Images), sem fornecer links ou imagens, apenas a descrição exata e sucinta do que deve ser procurado. Faça a adição de imagens apenas em locais extremamente importantes e imprescindíveis ao aprendizado, para evitar poluir o PDF.

Seja objetivo, técnico e pedagogicamente organizado.

Retorne apenas o conteúdo em Markdown, sem qualquer outro tipo de resposta.

Transcrição da aula:
{transcricao}
"""
    data = {
        "contents": [
            {
                "parts": [
                    {"text": prompt}
                ]
            }
        ]
    }

    response = requests.post(URL, headers=headers, json=data)

    if response.status_code == 200:
        result = response.json()
        markdown_raw = result['candidates'][0]['content']['parts'][0]['text']

        if markdown_raw.startswith("```markdown") and markdown_raw.endswith("```"):
            markdown_clean = "\n".join(markdown_raw.strip().split("\n")[1:-1])
        else:
            markdown_clean = markdown_raw

        titulo = ""
        for line in markdown_clean.split("\n"):
            if line.strip().startswith("# "):
                titulo = line.strip("# ").strip()
                break

        titulo = titulo + '.pdf'
        return titulo, markdown_clean
    else:
        raise Exception(f"Erro na requisição: {response.status_code}\n{response.text}")

def gerar_questoes_markdown(texto_base):
    prompt = f"""
    A partir do conteúdo abaixo, crie 10 questões de cada nível de dificuldade (fácil, médio, difícil), com foco em reforço de compreensão médica e acadêmica. Siga as regras:

    - Crie 10 questões fáceis, 10 médias e 10 difíceis.
    - Não agrupe as questões em fáceis, médias ou dificeis, o aluno só deve saber ao ver o gabarito.
    - Faça da questão 01 até a 30, sem agrupar por dificuldade.
    - As respostas das questões devem estar APENAS excluivamente na área de gabaritos.
    - As questões devem ser formuladas em formatos variados:
      - Questões objetivas (com alternativas)
      - Questões de resposta curta
      - Questões de verdadeiro ou falso
      - Casos clínicos

    - As alternativas, ou as respostas curtas, devem ser realistas e educativas, com a resposta correta claramente identificada.
    - As alternativas devem ser equilibradas em dificuldade, sem nenhuma óbvia ou excessivamente fácil.
    - Cada questão deve ser seguida de justificativa detalhada explicando o raciocínio por trás da resposta correta.
    - Não forneça explicações adicionais além das instruções acima.

    A saída deve estar no formato Markdown, com as questões bem organizadas e agradáveis para visualização e impressão. Evite usar links e mantenha a formatação simples, para que as questões sejam facilmente legíveis e prontas para serem impressas. As alternativas devem ser listadas de forma clara, e cada justificativa deve vir logo após a questão correspondente.

    Para as questões de resposta curta, inclua um espaço de linhas (sublinhado) do tamanho necessário para a resposta, usando a seguinte formatação:
    ________________________

    Saída: Responda no formato Markdown com as seguintes informações:

    ### Questões:

    1.  **Pergunta:** (enunciado da questão)
       - Alternativas:
         - A) Alternativa 1
         - B) Alternativa 2
         - C) Alternativa 3
         - D) Alternativa 4
         - E) Alternativa 5

    2.  **Pergunta:** (enunciado da questão)
       - Alternativas:
         - A) Verdadeiro
         - B) Falso (justificar aqui:______________________________)

    3. **Pergunta:** (enunciado da questão)
       **Resposta:**
       _____________________________________________________________

    Repita as 30 questões, seguindo o mesmo formato

    ### Gabarito:
    1. **Resposta:** A
       **Justificativa:** Explicação detalhada do porquê a alternativa A é a correta.
       **Nível: fácil/médio/difícil**

    2. **Resposta:** B
       **Justificativa:** Explicação detalhada do porquê a alternativa B é a correta.
       **Nível: fácil/médio/difícil**

    3. **Resposta:** Falso
       **Justificativa:** Explicação detalhada do que tornou a questão falsa ou verdadeira.
       **Nível: fácil/médio/difícil**

    (Repita para todas as questões)

    ### Texto base:
    {texto_base}
    """
    data = {"contents": [{"parts": [{"text": prompt}]}]}

    response = requests.post(URL, headers=headers, json=data)

    if response.status_code == 200:
        result = response.json()
        markdown_raw = result['candidates'][0]['content']['parts'][0]['text']

        markdown_clean = markdown_raw.strip().split("\n", 1)[-1].strip()  # Clean and trim the result

        titulo = 'questoes'
        return f"{titulo}.pdf", markdown_clean
    else:
        raise Exception(f"Erro na requisição: {response.status_code}\n{response.text}")

"""## Execução da Transcrição e Passagem ao PDF."""

def escolher_dispositivo():
    if torch.cuda.is_available():
        return "cuda"
    else:
        return "cpu"

def formatar_timestamp(segundos):
    h, m = divmod(int(segundos), 3600)
    m, s = divmod(m, 60)
    return f"{h:02}:{m:02}:{s:02}"

def remover_stopwords(texto):
    try:
        stopwords.words('portuguese')
    except LookupError:
        nltk.download('stopwords')

    stop_words = set(stopwords.words("portuguese"))
    texto_sem_pontuacao = texto.translate(str.maketrans('', '', string.punctuation))
    palavras = texto_sem_pontuacao.split()

    palavras_filtradas = [
        palavra for palavra in palavras
        if palavra.lower() not in stop_words
    ]
    return " ".join(palavras_filtradas)

def transcrever_audio(caminho_audio, modelo="base", exportar=True, dispositivo="cpu"):
    if not os.path.exists(caminho_audio):
        raise FileNotFoundError(f"Arquivo não encontrado: {caminho_audio}")

    print(f"🔍 Carregando modelo Whisper '{modelo}' no dispositivo {dispositivo.upper()}...")
    model = whisper.load_model(modelo).to(dispositivo)

    print("📡 Transcrevendo áudio...")
    resultado = model.transcribe(caminho_audio, verbose=False, language=sigla)

    com_tempos = []
    sem_tempos = []

    for s in resultado['segments']:
        texto = s['text'].strip()
        com_tempos.append(f"[{formatar_timestamp(s['start'])} - {formatar_timestamp(s['end'])}] {texto}")
        sem_tempos.append(texto)

    texto_com_tempos = "\n\n".join(com_tempos)
    texto_sem_tempos = " ".join(sem_tempos)
    texto_sem_tempos = remover_stopwords(texto_sem_tempos)

    print("\n✅ Transcrição finalizada!\n")
    if exportar:
        salvar_transcricoes(texto_com_tempos, texto_sem_tempos, caminho_audio)

    return texto_com_tempos, texto_sem_tempos

def salvar_transcricoes(com_tempos, sem_tempos, caminho_audio):
    base = os.path.splitext(os.path.basename(caminho_audio))[0]
    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")

    arquivos = {
        f"com_tempos_{base}.txt": com_tempos,
        f"sem_tempos_{base}.txt": sem_tempos
    }

    for nome, conteudo in arquivos.items():
        with open(nome, "w", encoding="utf-8") as f:
            f.write(conteudo)
        print(f"📁 Arquivo salvo: {nome}")

def mover_arquivos_processados(pasta_destino, base_nome):
    extensoes = (".txt", '.apkg')
    for arquivo in os.listdir("."):
        if base_nome in arquivo and arquivo.endswith(extensoes):
            origem = os.path.join(".", arquivo)
            destino = os.path.join(pasta_destino, arquivo)
            shutil.move(origem, destino)
            print(f"📦 Arquivo movido: {arquivo}")

def escolher_arquivo_audio(diretorio):
    arquivos_audio = [f for f in os.listdir(diretorio) if f.lower().endswith(('.mp3', '.wav', '.m4a'))]

    if len(arquivos_audio) == 0:
        print("❌ Nenhum arquivo de áudio encontrado na raiz.")
        return None

    if len(arquivos_audio) == 1:
        return arquivos_audio[0]

    print("🔊 Múltiplos arquivos de áudio encontrados. Escolha um para processar via flag --audio.")
    print('Ver documentação.')
    return (2/0)/0


#MAIN .PY
def transcrever_Resumir(diretorio):
    arquivo_audio = escolher_arquivo_audio(diretorio)

    if arquivo_audio:
        caminho_audio = os.path.join(diretorio, arquivo_audio)
        modelo = Modelo
        dispositivo = escolher_dispositivo()

        nome_arquivo_sem_ext = os.path.splitext(arquivo_audio)[0]
        pasta_destino = os.path.join("aulas_processadas", nome_arquivo_sem_ext)

        if os.path.exists(pasta_destino):
            print(f"⚠️ Sobrescrevendo")
        else:
            os.makedirs(pasta_destino)

        try:
            # Verificar se os arquivos com_tempos_ e sem_tempos_ já existem
            arquivo_com_tempos = os.path.join('.', f"com_tempos_{nome_arquivo_sem_ext}.txt")
            arquivo_sem_tempos = os.path.join('.', f"sem_tempos_{nome_arquivo_sem_ext}.txt")

            if os.path.exists(arquivo_com_tempos) and os.path.exists(arquivo_sem_tempos):
                print("🔄 Arquivos encontrados, carregando...")
                with open(arquivo_com_tempos, 'r') as f:
                    withTime = f.read()
                with open(arquivo_sem_tempos, 'r') as f:
                    noTime = f.read()
            else:
                print("🔄 Realizando transcrição...")
                withTime, noTime = transcrever_audio(caminho_audio, modelo=modelo, exportar=True, dispositivo=dispositivo)
                nonNormat = noTime #PARA O RESUMO, O NÃO NORMATIZADO TEM RESULTADOS LIGEIRAMENTE MELHORES, PORTANTO, RESUMO FEITO COM NONNORMAT.
                print("\n📝 Normatizando fala.")
                varbs, noTime = normatizarFala(noTime)
                print("\n✅ Texto completo!")

                # Salvar os arquivos gerados
                with open(arquivo_com_tempos, 'w') as f:
                    f.write(withTime)
                with open(arquivo_sem_tempos, 'w') as f:
                    f.write(noTime)


            print("\n📝 Criando resumo")
            tituloMD, resumoMD = gerar_resumo_markdown(nonNormat)
            print("\n✅ Resumo pronto!")

            print("\n📝 Criando questões")
            tituloQuestoes, QuestoesMD = gerar_questoes_markdown(resumoMD)
            print("\n✅ Questões prontas!")

            print('\n📝Criando Flashcards')
            jsonFlashCards = gerarFlashcards(resumoMD)
            criar_baralho(flashcards=jsonFlashCards, nome_baralho=nome_arquivo_sem_ext)
            print("\n✅ Flashcards prontas!")

            gerar_pdf_markdown(resumoMD, pasta_destino, "resumo.pdf")
            gerar_pdf_markdown(QuestoesMD, pasta_destino, "questoes.pdf")

            # Mover os arquivos usados para a pasta destino
            mover_arquivos_processados(f"aulas_processadas/{nome_arquivo_sem_ext}", nome_arquivo_sem_ext)
            # Criar um arquivo ZIP com os arquivos processados
            zip_filename = f"{nome_arquivo_sem_ext}_aulas"
            shutil.make_archive(zip_filename, 'zip', pasta_destino)

            # Fazer o download do arquivo ZIP
            files.download(f"{zip_filename}.zip")

        except Exception as erro:
            print(f"❌ Erro: {erro}")

"""# Execução"""

transcrever_Resumir('.')
driver.quit()